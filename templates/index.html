<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Page OCR to PDF Converter</title>
    <style>
        /* --- General Layout and Typography --- */
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
            background-color: #f0f2f5; 
            color: #333;
        }
        h1 { text-align: center; color: #1f4287; margin-bottom: 30px; }
        h2 { border-bottom: 2px solid #e0e0e0; padding-bottom: 10px; margin-top: 0; color: #444; }
        
        /* --- Main App Grid Layout --- */
        .app-grid {
            display: grid;
            grid-template-columns: 1fr 2fr; /* One column for controls, two for viewer/text */
            gap: 20px;
            margin-top: 20px;
        }
        @media (max-width: 900px) {
            .app-grid {
                grid-template-columns: 1fr; /* Stack columns on smaller screens */
            }
        }
        
        .section-panel { 
            background-color: #fff; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.1); 
            height: fit-content;
        }
        .main-content {
            grid-column: 2 / 3; /* Occupy the second column */
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        @media (max-width: 900px) {
            .main-content {
                grid-column: 1 / 2; /* Revert to single column */
            }
        }

        /* --- Input & Control Styles (Minor fix: removed margin-bottom from file input to align with label) --- */
        .input-group label { display: block; margin-bottom: 5px; font-weight: 600; color: #555; }
        input[type="file"], select, input[type="text"] { 
            width: 100%; 
            padding: 10px; 
            border: 1px solid #ccc; 
            border-radius: 4px; 
            box-sizing: border-box; 
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        #ocrText { 
            width: 100%; 
            height: 350px; 
            padding: 15px; 
            box-sizing: border-box; 
            resize: vertical; 
            border: 1px solid #ccc; 
            border-radius: 4px; 
            font-family: monospace; 
            font-size: 14px;
        }
        
        .button-group { display: flex; justify-content: flex-end; margin-top: 15px; gap: 10px; }
        button { 
            padding: 12px 20px; 
            border-radius: 6px; 
            cursor: pointer; 
            border: none; 
            font-weight: bold; 
            transition: background-color 0.2s; 
        }
        /* Style for scan buttons */
        #uploadBtn { 
            background-color: #007bff; 
            color: white; 
            width: 100%; 
            margin-top: 5px; 
        }
        #uploadBtn:hover { background-color: #0056b3; }

        #scanNextBtn {
            background-color: #17a2b8; /* Info blue/cyan */
            color: white;
            width: 100%;
            margin-top: 5px;
            /* FIX: Ensure it is hidden by default on page load */
            display: none; 
        }
        #scanNextBtn:hover { background-color: #138496; }

        #pdfBtn { 
            background-color: #28a745; 
            color: white; 
            /* FIX: Ensure it is hidden by default on page load */
            display: none; 
        }
        #pdfBtn:hover { background-color: #1e7e34; }
        
        /* Local Storage Buttons */
        #saveTextBtn { background-color: #ffc107; color: #343a40; margin-top: 10px; width: 100%; padding: 8px; }
        #saveTextBtn:hover { background-color: #e0a800; }
        .local-file-actions { display: flex; gap: 5px; margin-top: 5px;}
        .local-file-actions button { flex-grow: 1; padding: 5px; font-size: 0.8em; }

        .loading { color: #007bff; margin-top: 10px; font-weight: bold; display: none; }

        /* --- Tesseract Status --- */
        .tesseract-status {
            padding: 10px;
            border-radius: 4px;
            font-size: 0.9em;
            margin-bottom: 15px;
            word-wrap: break-word; 
        }
        .status-ok { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6fb; }

        /* --- Flashed Messages --- */
        .alert { padding: 15px; margin-bottom: 20px; border-radius: 4px; font-weight: 500; }
        .alert-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .alert-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6fb; }
        .alert-warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }

        /* --- Image Viewer --- */
        #imageWrapper {
            overflow: auto; /* Allows scrolling when zoomed in */
            max-height: 500px; /* Limit height for better layout */
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            text-align: center;
            background-color: #f9f9f9;
        }

        #scannedImage { 
            max-width: 100%; 
            display: none; 
            transform-origin: top left;
        }
        
        .zoom-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .zoom-controls button {
            padding: 8px 15px;
            font-size: 1.1em;
            background-color: #6c757d;
            color: white;
            width: auto;
            border-radius: 4px;
        }
        .zoom-controls button:hover {
            background-color: #5a6268;
        }


        /* Local Storage List styles (omitted for brevity, assume they are correct) */
        #savedFilesList {
            list-style: none;
            padding: 0;
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        #savedFilesList li {
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #savedFilesList li:last-child { border-bottom: none; }
        .file-name {
            flex-grow: 1;
            font-size: 0.9em;
            color: #1f4287;
            cursor: pointer;
        }
    </style>
</head>
<body>
    
    {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            {% for category, message in messages %}
            <div class="alert alert-{{ category }}">{{ message }}</div>
            {% endfor %}
        {% endif %}
    {% endwith %}

    <h1>ðŸ¤– Multi-Page OCR & PDF Creator</h1>

    <div class="app-grid">
        <div class="section-panel controls-panel">
            <h2>Settings & Status</h2>
            
            <div class="tesseract-status {% if tesseract_ok %}status-ok{% else %}status-error{% endif %}">
                <strong>OCR Engine Status:</strong>
                <p>{{ tesseract_status }}</p>
            </div>

            <div class="input-group">
                <label for="imageFile">1. Select Document (Image, TIFF, PDF) - Max 5MB</label>
                <input type="file" id="imageFile" accept="image/*,.pdf,.tif,.tiff">
            </div>

            <div class="input-group">
                <label for="ocrLang">2. Select OCR Language</label>
                <select id="ocrLang">
                    <option value="eng" {% if last_language == 'eng' %}selected{% endif %}>English (eng)</option>
                    <option value="fra" {% if last_language == 'fra' %}selected{% endif %}>French (fra)</option>
                    <option value="deu" {% if last_language == 'deu' %}selected{% endif %}>German (deu)</option>
                    <option value="spa" {% if last_language == 'spa' %}selected{% endif %}>Spanish (spa)</option>
                    <option value="ita" {% if last_language == 'ita' %}selected{% endif %}>Italian (ita)</option>
                    </select>
            </div>
            
            <div class="input-group">
                <label for="ocrPsm">3. OCR Page Segmentation Mode (PSM)</label>
                <select id="ocrPsm">
                    <option value="3" selected>3 - Fully automatic page segmentation (Default)</option>
                    <option value="6">6 - Assume a single uniform block of text (Best for simple docs)</option>
                    <option value="1">1 - Automatic page segmentation with OSD (Orientation)</option>
                    <option value="7">7 - Treat the image as a single text line</option>
                    <option value="8">8 - Treat the image as a single word</option>
                    <option value="10">10 - Treat the image as a single character</option>
                </select>
            </div>

            <button id="uploadBtn">4. Start OCR Scan (Initial)</button>
            <button id="scanNextBtn" style="display: none;">4. Scan Next Page/Image (Append to Text)</button>
            
            <div class="loading" id="loadingMessage">Processing document... This may take a moment for multi-page files.</div>

            <hr style="margin-top: 20px;">

            <h2>Local Document Storage (Browser)</h2>
            <div class="input-group">
                <label for="localFileName">Save Document Name (Current Text)</label>
                <input type="text" id="localFileName" placeholder="Enter name for local save">
            </div>
            <button id="saveTextBtn">Save Current Text Locally</button>
            <p style="font-size: 0.85em; color: #777; margin-top: 5px;">*Saved only in this browser.</p>
            
            <ul id="savedFilesList">
            </ul>
            <hr>
            
            <h2>PDF Output</h2>
            
            <div class="input-group">
                <label for="pdfFont">PDF Font Style</label>
                <select id="pdfFont">
                    <option value="Arial" selected>Arial (Default)</option>
                    <option value="Times">Times New Roman</option>
                    <option value="Courier">Courier</option>
                </select>
            </div>

            <div class="input-group">
                <label for="pdfTitle">PDF Document Title (e.g., Invoice-2024)</label>
                <input type="text" id="pdfTitle" placeholder="Enter desired filename" 
                                value="{{ last_pdf_title }}">
            </div>
            <div class="button-group">
                <button id="pdfBtn">5. Download Final PDF</button>
            </div>
        </div>

        <div class="main-content">
            <div class="section-panel">
                <h2>Document Viewer (Page 1 Preview)</h2>
                <div id="imageWrapper">
                    <img id="scannedImage" alt="Scanned Document Preview">
                </div>
                <div class="zoom-controls">
                    <button id="zoomInBtn" title="Zoom In">+</button>
                    <button id="zoomOutBtn" title="Zoom Out">-</button>
                    <button id="zoomResetBtn" title="Reset Zoom">Reset</button>
                </div>
            </div>

            <div class="section-panel">
                <h2>Extracted Text Editor</h2>
                <textarea id="ocrText" placeholder="The extracted text will appear here. Edit it as needed. Pages are separated by '--- PAGE X ---'." disabled></textarea>
            </div>
        </div>
    </div>

    <script>
        const STORAGE_KEY = 'ocr_saved_documents';
        const MAX_FILE_SIZE_BYTES = 5 * 1024 * 1024; 
        const fileInput = document.getElementById('imageFile');
        const ocrTextarea = document.getElementById('ocrText');
        const pdfButton = document.getElementById('pdfBtn');
        const loadingMessage = document.getElementById('loadingMessage');
        const imageElement = document.getElementById('scannedImage');
        const savedFilesList = document.getElementById('savedFilesList');
        const localFileNameInput = document.getElementById('localFileName');
        
        let currentPageCount = 0; 
        const uploadBtn = document.getElementById('uploadBtn');
        const scanNextBtn = document.getElementById('scanNextBtn');
        
        // Zoom variables
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');
        let currentZoom = 1.0;
        const zoomStep = 0.2;
        const minZoom = 0.5;
        const maxZoom = 5.0;


        // --- Zoom Functions ---
        function applyZoom() {
            // Apply zoom using CSS transform: scale() for smooth scaling
            imageElement.style.transform = `scale(${currentZoom})`;
            
            // Adjust max-width based on zoom to allow it to exceed 100% and enable scrolling
            if (currentZoom > 1.0) {
                // Allows the element to expand beyond its container, enabling the wrapper's overflow: auto
                imageElement.style.maxWidth = `${currentZoom * 100}%`;
            } else {
                imageElement.style.maxWidth = '100%';
            }
        }

        zoomInBtn.addEventListener('click', () => {
            if (currentZoom < maxZoom) {
                currentZoom = Math.min(maxZoom, currentZoom + zoomStep);
                applyZoom();
            }
        });

        zoomOutBtn.addEventListener('click', () => {
            if (currentZoom > minZoom) {
                currentZoom = Math.max(minZoom, currentZoom - zoomStep);
                applyZoom();
            }
        });

        zoomResetBtn.addEventListener('click', () => {
            currentZoom = 1.0;
            applyZoom();
        });

        // Reset zoom whenever a new image is loaded
        imageElement.addEventListener('load', () => {
            currentZoom = 1.0;
            applyZoom();
        });


        // --- Utility Function: Render Saved Files List ---
        function renderSavedFiles() {
            savedFilesList.innerHTML = '';
            let savedData;
            try {
                savedData = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            } catch (e) {
                console.error("Error parsing local storage data:", e);
                savedData = [];
            }
            
            if (savedData.length === 0) {
                savedFilesList.innerHTML = '<li style="color: #777;">No documents saved locally.</li>';
                return;
            }

            savedData.forEach(item => {
                const li = document.createElement('li');
                const timestamp = new Date(parseInt(item.timestamp)).toLocaleString();
                
                li.innerHTML = `
                    <span class="file-name" data-id="${item.timestamp}" title="Click to Load Text">${item.name} (${timestamp})</span>
                    <div class="local-file-actions">
                        <button class="btn btn-sm" onclick="loadText('${item.timestamp}')" style="background-color: #007bff; color: white;">Load</button>
                        <button class="btn btn-sm" onclick="deleteText('${item.timestamp}')" style="background-color: #dc3545; color: white;">Delete</button>
                    </div>
                `;
                savedFilesList.appendChild(li);
            });
        }

        // --- Local Storage Functions (made global for onclick) ---
        window.loadText = function(timestamp) {
            const savedData = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            const item = savedData.find(doc => doc.timestamp === timestamp);

            if (item && confirm(`Load "${item.name}" into the editor? Current text will be lost.`)) {
                ocrTextarea.value = item.text;
                ocrTextarea.disabled = false;
                pdfButton.style.display = 'block';
                document.getElementById('pdfTitle').value = item.name.replace(/\s*\(.*\)$/, ''); 
                
                // Reset page count (since we're loading a composite document) and show 'scan next'
                currentPageCount = 0; 
                scanNextBtn.style.display = 'block';
                
                alert(`Document "${item.name}" loaded for editing.`);
            }
        };

        window.deleteText = function(timestamp) {
            if (confirm("Are you sure you want to permanently delete this document from your browser's local storage?")) {
                let savedData = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
                const originalLength = savedData.length;
                
                savedData = savedData.filter(doc => doc.timestamp !== timestamp);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(savedData));

                if (savedData.length < originalLength) {
                    alert('Document deleted successfully.');
                    renderSavedFiles();
                }
            }
        };
        
        document.getElementById('saveTextBtn').addEventListener('click', () => {
            const textToSave = ocrTextarea.value;
            let fileName = localFileNameInput.value.trim() || 'Untitled Document';

            if (!textToSave.trim()) {
                alert('The text editor is empty. Nothing to save.');
                return;
            }

            const savedData = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            const newDoc = {
                name: fileName,
                text: textToSave,
                timestamp: Date.now().toString()
            };

            savedData.push(newDoc);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(savedData));

            alert(`Text saved locally as "${fileName}".`);
            localFileNameInput.value = '';
            renderSavedFiles();
        });


        // --- CORE OCR & MULTI-SCAN PROCESSING ---

        // FIX: Add event listener to file input for client-side preview
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    imageElement.src = e.target.result;
                    imageElement.style.display = 'block';
                    // Check if initial scan was already performed
                    if (ocrTextarea.value.trim() !== '') {
                        scanNextBtn.style.display = 'block';
                    }
                };
                reader.readAsDataURL(file);
            } else if (file) {
                // For PDF/TIFF, show a placeholder since we can't easily preview client-side
                imageElement.src = '';
                imageElement.style.display = 'none';
            }
        });


        /**
         * Validates the selected file and runs the OCR scan.
         * @param {boolean} appendMode - True if this is a subsequent scan to append text.
         */
        async function runOcrScan(appendMode = false) {
            const file = fileInput.files[0];
            
            // --- Client-side validation for file existence and size ---
            if (!file) {
                alert('Please select a document file first.');
                return;
            }
            if (file.size > MAX_FILE_SIZE_BYTES) {
                alert(`File is too large. Max size is ${MAX_FILE_SIZE_BYTES / 1024 / 1024}MB.`);
                fileInput.value = ''; // Clear the input
                imageElement.style.display = 'none'; // Hide image
                return;
            }
            
            const language = document.getElementById('ocrLang').value;
            const psm = document.getElementById('ocrPsm').value; 
            const isInitialScan = !appendMode;

            loadingMessage.style.display = 'block';
            ocrTextarea.disabled = true;
            pdfButton.style.display = 'none';
            
            if (isInitialScan) {
                ocrTextarea.value = ''; 
                currentPageCount = 0; 
                // Hide scan next button until the first scan is complete
                scanNextBtn.style.display = 'none'; 
            }
            
            uploadBtn.disabled = true;
            scanNextBtn.disabled = true;

            const formData = new FormData();
            formData.append('file', file);
            formData.append('language', language);
            formData.append('psm', psm);

            try {
                // FIX: Assuming the server is running on the current host and /upload is the correct endpoint
                const response = await fetch('/upload', { 
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json(); 
                    let scannedText = data.text;
                    
                    if (appendMode) {
                        const regex = /--- PAGE (\d+) ---/g;
                        let newText = '';
                        
                        // Handle multi-page documents from the server's response
                        const pageMatches = scannedText.match(regex);
                        if (pageMatches) {
                            // This logic correctly re-indexes pages from the new scan, assuming the server
                            // returns Tesseract's own multi-page markers.
                            const textParts = scannedText.split(regex).slice(1); 
                            for (let i = 0; i < textParts.length; i += 2) {
                                // textParts[i] is the page number, textParts[i+1] is the content
                                const pageContent = textParts[i + 1].trim(); 
                                currentPageCount++;
                                newText += `\n\n======================================================\n--- APPENDED PAGE ${currentPageCount} (from file: ${data.filename}) ---\n======================================================\n\n` + pageContent;
                            }
                        } else {
                            // Assume a single image/page was scanned
                            currentPageCount++;
                            newText = `\n\n======================================================\n--- APPENDED PAGE ${currentPageCount} (from file: ${data.filename}) ---\n======================================================\n\n` + scannedText;
                        }

                        ocrTextarea.value += newText;

                    } else {
                        // Initial scan: use text directly and update count
                        ocrTextarea.value = scannedText;
                        const pageMatches = scannedText.match(/--- PAGE (\d+) ---/g);
                        currentPageCount = pageMatches ? pageMatches.length : 1;
                        
                        document.getElementById('pdfTitle').value = data.filename.split('.').slice(0, -1).join('.'); 
                        
                        // FIX: Image preview on initial scan - We'll rely on the fileInput 'change' listener for client-side image files, 
                        // but if it's a multi-page PDF/TIFF, the server must provide the *first page* image data or file path here.
                        // Assuming the server response 'data.filename' points to a *viewable* first page image (e.g., in a /uploads folder)
                        // This server-side path is necessary for PDF/TIFF files.
                        if (file.type.startsWith('image/')) {
                            // Do nothing, the 'change' listener already set the preview
                        } else {
                            // Use server-provided image path (e.g., converted first page of PDF)
                            imageElement.src = '/uploads/' + data.filename + '_page_1.png'; // Placeholder for server-generated first page image
                            imageElement.style.display = 'block';
                        }
                    }
                    
                    ocrTextarea.disabled = false;
                    pdfButton.style.display = 'block'; 
                    scanNextBtn.style.display = 'block'; 
                    
                } else {
                    const error = await response.text();
                    ocrTextarea.value = `Processing failed. Server message: ${error}`;
                    alert('OCR processing failed. Check editor and flash message for details.');
                }
            } catch (error) {
                console.error('Fetch error:', error);
                alert('A network error occurred. Check server connection.');
            } finally {
                loadingMessage.style.display = 'none';
                uploadBtn.disabled = false;
                scanNextBtn.disabled = false;
                fileInput.value = ''; // Clear input for next file selection
            }
        }
        
        uploadBtn.addEventListener('click', () => runOcrScan(false));
        scanNextBtn.addEventListener('click', () => runOcrScan(true));


        // --- PDF DOWNLOAD LOGIC ---
        document.getElementById('pdfBtn').addEventListener('click', async (e) => {
            e.preventDefault(); 
            
            const editedText = ocrTextarea.value;
            const pdfTitleInput = document.getElementById('pdfTitle').value.trim();
            const pdfFont = document.getElementById('pdfFont').value;
            
            let downloadName = pdfTitleInput || 'scanned_document';
            // Ensure .pdf extension is present
            downloadName = downloadName.endsWith('.pdf') ? downloadName : downloadName + '.pdf';

            if (!editedText.trim()) {
                alert('The text area is empty. Nothing to convert.');
                return;
            }

            const body = new URLSearchParams();
            body.append('edited_text', editedText);
            body.append('download_name', downloadName);
            body.append('pdf_font', pdfFont);

            try {
                // Show a brief message, as PDF generation can take a moment
                loadingMessage.textContent = 'Generating PDF...';
                loadingMessage.style.display = 'block';
                pdfButton.disabled = true;

                // FIX: Assuming the server is running on the current host and /generate_pdf is the correct endpoint
                const response = await fetch('/generate_pdf', {
                    method: 'POST',
                    body: body,
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    }
                });

                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = downloadName; 
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url); 
                } else {
                    const error = await response.text();
                    alert(`PDF Generation Failed. Server error: ${error}`);
                    console.error('PDF Generation Error:', error);
                }
            } catch (error) {
                console.error('Network Error during PDF generation:', error);
                alert('A network error occurred during PDF generation.');
            } finally {
                loadingMessage.style.display = 'none';
                loadingMessage.textContent = 'Processing document... This may take a moment for multi-page files.';
                pdfButton.disabled = false;
            }
        });

        document.addEventListener('DOMContentLoaded', renderSavedFiles);

    </script>
</body>
</html>